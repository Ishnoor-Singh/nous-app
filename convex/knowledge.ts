import { v } from "convex/values";
import { mutation, query } from "./_generated/server";

const TOPICS = ["philosophy", "history", "economics", "art", "psychology"] as const;

// Get today's knowledge cards for a user
export const getTodayCards = query({
  args: { userId: v.id("users") },
  handler: async (ctx, args) => {
    const today = new Date().toISOString().split("T")[0];
    
    return await ctx.db
      .query("knowledgeCards")
      .withIndex("by_user_day", (q) => 
        q.eq("userId", args.userId).eq("dayGenerated", today)
      )
      .collect();
  },
});

// Generate daily cards (called when user opens app and no cards exist for today)
export const generateDailyCards = mutation({
  args: { userId: v.id("users") },
  handler: async (ctx, args) => {
    const today = new Date().toISOString().split("T")[0];
    
    // Check if cards already exist
    const existing = await ctx.db
      .query("knowledgeCards")
      .withIndex("by_user_day", (q) => 
        q.eq("userId", args.userId).eq("dayGenerated", today)
      )
      .first();

    if (existing) return; // Cards already generated

    // Get user's learning progress to personalize
    const progress = await ctx.db
      .query("learningProgress")
      .withIndex("by_user", (q) => q.eq("userId", args.userId))
      .first();

    // Weight topics by interest
    const interests = progress?.topicInterests || {
      philosophy: 0.5,
      history: 0.5,
      economics: 0.5,
      art: 0.5,
      psychology: 0.5,
    };

    // Select 3 topics weighted by interest
    const weightedTopics = TOPICS.map(topic => ({
      topic,
      weight: interests[topic] + Math.random() * 0.3, // Add some randomness
    }));
    weightedTopics.sort((a, b) => b.weight - a.weight);
    const selectedTopics = weightedTopics.slice(0, 3).map(t => t.topic);

    // Create placeholder cards (actual content generated by AI on request)
    for (const topic of selectedTopics) {
      await ctx.db.insert("knowledgeCards", {
        userId: args.userId,
        topic,
        title: `Today's ${topic} discovery`, // Placeholder - AI will fill this
        summary: "", // Empty until user explores
        depth: 0,
        completed: false,
        dayGenerated: today,
        createdAt: Date.now(),
      });
    }
  },
});

// Mark a card as completed and track depth
export const completeCard = mutation({
  args: {
    cardId: v.id("knowledgeCards"),
    depth: v.number(), // How deep did they go (1-5)
    title: v.optional(v.string()),
    summary: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.cardId, {
      completed: true,
      depth: args.depth,
      ...(args.title && { title: args.title }),
      ...(args.summary && { summary: args.summary }),
    });

    // Update user's streak
    const card = await ctx.db.get(args.cardId);
    if (!card) return;

    const progress = await ctx.db
      .query("learningProgress")
      .withIndex("by_user", (q) => q.eq("userId", card.userId))
      .first();

    if (!progress) return;

    const today = new Date().toISOString().split("T")[0];
    const yesterday = new Date(Date.now() - 86400000).toISOString().split("T")[0];

    let newStreak = progress.currentStreak;
    if (progress.lastActiveDay === yesterday) {
      newStreak += 1;
    } else if (progress.lastActiveDay !== today) {
      newStreak = 1; // Streak broken, start over
    }

    await ctx.db.patch(progress._id, {
      currentStreak: newStreak,
      longestStreak: Math.max(progress.longestStreak, newStreak),
      lastActiveDay: today,
      totalCardsCompleted: progress.totalCardsCompleted + 1,
      topicInterests: {
        ...progress.topicInterests,
        [card.topic]: Math.min(1, progress.topicInterests[card.topic as keyof typeof progress.topicInterests] + 0.05),
      },
    });
  },
});

// Get user's learning stats
export const getStats = query({
  args: { userId: v.id("users") },
  handler: async (ctx, args) => {
    const progress = await ctx.db
      .query("learningProgress")
      .withIndex("by_user", (q) => q.eq("userId", args.userId))
      .first();

    const allCards = await ctx.db
      .query("knowledgeCards")
      .withIndex("by_user", (q) => q.eq("userId", args.userId))
      .collect();

    const completedCards = allCards.filter(c => c.completed);
    const avgDepth = completedCards.length > 0
      ? completedCards.reduce((sum, c) => sum + c.depth, 0) / completedCards.length
      : 0;

    return {
      currentStreak: progress?.currentStreak || 0,
      longestStreak: progress?.longestStreak || 0,
      totalCardsCompleted: progress?.totalCardsCompleted || 0,
      averageDepth: avgDepth,
      topicInterests: progress?.topicInterests,
    };
  },
});
